# Big O

> –û—Å–Ω–æ–≤–∞ –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –∫–æ–¥–∞ –∏ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –∫ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–º –∏–Ω—Ç–µ—Ä–≤—å—é

## Big O
- –≠—Ç–æ –Ω–æ—Ç–∞—Ü–∏—è, –∫–æ—Ç–æ—Ä–∞—è –æ–ø–∏—Å—ã–≤–∞–µ—Ç –≤–µ—Ä—Ö–Ω—é—é –≥—Ä–∞–Ω–∏—Ü—É –≤—Ä–µ–º–µ–Ω–∏
–≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö.

**–û—Å–Ω–æ–≤–Ω—ã–µ –ø—Ä–∏–Ω—Ü–∏–ø—ã:**
- –û–ø–∏—Å—ã–≤–∞–µ—Ç **–Ω–∞–∏—Ö—É–¥—à–∏–π —Å–ª—É—á–∞–π**
- –ò–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ –º–ª–∞–¥—à–∏–µ —Å–ª–∞–≥–∞–µ–º—ã–µ
- –§–æ–∫—É—Å–∏—Ä—É–µ—Ç—Å—è –Ω–∞ **—Ä–æ—Å—Ç–µ** –≤—Ä–µ–º–µ–Ω–∏/–ø–∞–º—è—Ç–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –ø—Ä–∏ —É–≤–µ–ª–∏—á–µ–Ω–∏–∏ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö

---

## –ò–µ—Ä–∞—Ä—Ö–∏—è —Å–ª–æ–∂–Ω–æ—Å—Ç–µ–π

- O(1) : –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–µ –≤—Ä–µ–º—è | –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –Ω–µ **–∑–∞–≤–∏—Å–∏—Ç** –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- O(log n) :
- O(n) :
- O(n log n) :
- O(n¬≤) :
- O(2‚Åø) :
- O(n!) :

### O(1) - –ö–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–µ –≤—Ä–µ–º—è

**–û–ø–∏—Å–∞–Ω–∏–µ:** –í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –Ω–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö

#### Go
```go
// ==================== –ü–†–ò–ú–ï–†: –î–û–°–¢–£–ü –ö –≠–õ–ï–ú–ï–ù–¢–£ –ú–ê–°–°–ò–í–ê ====================
// –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1) - –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–µ –≤—Ä–µ–º—è
// –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1) - –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–∞—è –ø–∞–º—è—Ç—å

func getArrayElement(arr []int, index int) int {
    // –î–æ—Å—Ç—É–ø –∫ —ç–ª–µ–º–µ–Ω—Ç—É –º–∞—Å—Å–∏–≤–∞ –ø–æ –∏–Ω–¥–µ–∫—Å—É –≤—Å–µ–≥–¥–∞ –∑–∞–Ω–∏–º–∞–µ—Ç –æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ –≤—Ä–µ–º—è
    // –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ –º–∞—Å—Å–∏–≤–∞ (1 —ç–ª–µ–º–µ–Ω—Ç –∏–ª–∏ 1 –º–∏–ª–ª–∏–æ–Ω)
    return arr[index]  // –û–¥–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è - O(1)
}

// ==================== –ü–†–ò–ú–ï–†: –û–ü–ï–†–ê–¶–ò–ò –° –•–≠–®–ú–ê–ü–û–ô ====================
func hashMapOperations() {
    // –°–æ–∑–¥–∞–Ω–∏–µ —Ö—ç—à–º–∞–ø—ã
    cache := make(map[string]int)

    // –í—Å—Ç–∞–≤–∫–∞ - O(1) –≤ —Å—Ä–µ–¥–Ω–µ–º —Å–ª—É—á–∞–µ
    cache["key1"] = 100  // –ö–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–µ –≤—Ä–µ–º—è

    // –ü–æ–∏—Å–∫ - O(1) –≤ —Å—Ä–µ–¥–Ω–µ–º —Å–ª—É—á–∞–µ
    value := cache["key1"]  // –ö–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–µ –≤—Ä–µ–º—è

    // –£–¥–∞–ª–µ–Ω–∏–µ - O(1) –≤ —Å—Ä–µ–¥–Ω–µ–º —Å–ª—É—á–∞–µ
    delete(cache, "key1")  // –ö–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–µ –≤—Ä–µ–º—è
}

// ==================== –†–ï–ê–õ–¨–ù–û–ï –ü–†–ò–ú–ï–ù–ï–ù–ò–ï ====================
// - –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
// - –î–æ—Å—Ç—É–ø –∫ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
// - –û–ø–µ—Ä–∞—Ü–∏–∏ —Å–æ —Å—Ç–µ–∫–æ–º (push/pop —Å –∫–æ–Ω—Ü–∞)
```

#### Python
```python
# ==================== –ü–†–ò–ú–ï–† –ù–ê PYTHON ====================
# –û–ø–µ—Ä–∞—Ü–∏–∏ —Å –º–Ω–æ–∂–µ—Å—Ç–≤–æ–º (set) - O(1) –≤ —Å—Ä–µ–¥–Ω–µ–º

def set_operations():
    """
    –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è O(1) –æ–ø–µ—Ä–∞—Ü–∏–π —Å –º–Ω–æ–∂–µ—Å—Ç–≤–æ–º
    """
    # –°–æ–∑–¥–∞–Ω–∏–µ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ - O(1)
    visited = set()

    # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ - O(1) –≤ —Å—Ä–µ–¥–Ω–µ–º
    visited.add("user123")  # –ö–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–µ –≤—Ä–µ–º—è –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ set

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è - O(1) –≤ —Å—Ä–µ–¥–Ω–µ–º
    is_visited = "user123" in visited  # –ö–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–µ –≤—Ä–µ–º—è

    # –£–¥–∞–ª–µ–Ω–∏–µ - O(1) –≤ —Å—Ä–µ–¥–Ω–µ–º
    visited.remove("user123")  # –ö–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–µ –≤—Ä–µ–º—è

    return is_visited
```

### O(log n) - –õ–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–æ–µ –≤—Ä–µ–º—è

**–û–ø–∏—Å–∞–Ω–∏–µ:** –í—Ä–µ–º—è —Ä–∞—Å—Ç–µ—Ç –ª–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–∏. –ö–∞–∂–¥—ã–π —à–∞–≥ —É–º–µ–Ω—å—à–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—É –≤–¥–≤–æ–µ.

#### Go
```go
// ==================== –ü–†–ò–ú–ï–†: –ë–ò–ù–ê–†–ù–´–ô –ü–û–ò–°–ö ====================
// –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(log n) - –ª–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–æ–µ –≤—Ä–µ–º—è
// –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1) - –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–∞—è –ø–∞–º—è—Ç—å

func binarySearch(sortedArray []int, target int) int {
    // –ü–æ–∏—Å–∫ –≤ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –º–∞—Å—Å–∏–≤–µ
    left := 0                    // –õ–µ–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞
    right := len(sortedArray) - 1 // –ü—Ä–∞–≤–∞—è –≥—Ä–∞–Ω–∏—Ü–∞

    // –ü–æ–∫–∞ –µ—Å—Ç—å –æ–±–ª–∞—Å—Ç—å –¥–ª—è –ø–æ–∏—Å–∫–∞
    for left <= right {
        // –ù–∞—Ö–æ–¥–∏–º —Å—Ä–µ–¥–Ω–∏–π –∏–Ω–¥–µ–∫—Å (–∏–∑–±–µ–≥–∞–µ–º –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è)
        mid := left + (right-left)/2

        // ==================== –ê–ù–ê–õ–ò–ó –°–õ–û–ñ–ù–û–°–¢–ò ====================
        // –ö–∞–∂–¥–∞—è –∏—Ç–µ—Ä–∞—Ü–∏—è —É–º–µ–Ω—å—à–∞–µ—Ç –æ–±–ª–∞—Å—Ç—å –ø–æ–∏—Å–∫–∞ –≤ 2 —Ä–∞–∑–∞
        // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π = log‚ÇÇ(n)
        // –ù–∞–ø—Ä–∏–º–µ—Ä: –º–∞—Å—Å–∏–≤ 1000 —ç–ª–µ–º–µ–Ω—Ç–æ–≤ ‚Üí –º–∞–∫—Å–∏–º—É–º 10 –∏—Ç–µ—Ä–∞—Ü–∏–π

        if sortedArray[mid] == target {
            return mid  // –ù–∞–π–¥–µ–Ω —ç–ª–µ–º–µ–Ω—Ç - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–Ω–¥–µ–∫—Å
        } else if sortedArray[mid] < target {
            left = mid + 1  // –ò—â–µ–º –≤ –ø—Ä–∞–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ
        } else {
            right = mid - 1  // –ò—â–µ–º –≤ –ª–µ–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ
        }
    }

    return -1  // –≠–ª–µ–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω
}

// ==================== –ü–†–ò–ú–ï–† –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–Ø ====================
func exampleBinarySearch() {
    // –û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤ - –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ —É—Å–ª–æ–≤–∏–µ –¥–ª—è –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞
    numbers := []int{1, 3, 5, 7, 9, 11, 13, 15, 17, 19}

    // –ü–æ–∏—Å–∫ —á–∏—Å–ª–∞ 7
    index := binarySearch(numbers, 7)

    // –î–ª—è –º–∞—Å—Å–∏–≤–∞ –≤ 10 —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è –º–∞–∫—Å–∏–º—É–º log‚ÇÇ(10) ‚âà 4 –æ–ø–µ—Ä–∞—Ü–∏–∏
    // –î–ª—è –º–∞—Å—Å–∏–≤–∞ –≤ 1,000,000 —ç–ª–µ–º–µ–Ω—Ç–æ–≤ ‚Üí –º–∞–∫—Å–∏–º—É–º 20 –æ–ø–µ—Ä–∞—Ü–∏–π!
}
```

### O(n) - –õ–∏–Ω–µ–π–Ω–æ–µ –≤—Ä–µ–º—è

**–û–ø–∏—Å–∞–Ω–∏–µ:** –í—Ä–µ–º—è —Ä–∞—Å—Ç–µ—Ç –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ —Ä–∞–∑–º–µ—Ä—É –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö

```go
// ==================== –ü–†–ò–ú–ï–†: –õ–ò–ù–ï–ô–ù–´–ô –ü–û–ò–°–ö ====================
// –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n) - –ª–∏–Ω–µ–π–Ω–æ–µ –≤—Ä–µ–º—è
// –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1) - –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–∞—è –ø–∞–º—è—Ç—å

func linearSearch(array []int, target int) int {
    // ==================== –ê–ù–ê–õ–ò–ó –°–õ–û–ñ–ù–û–°–¢–ò ====================
    // –í —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç
    // –ï—Å–ª–∏ —ç–ª–µ–º–µ–Ω—Ç –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –∫–æ–Ω—Ü–µ –∏–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç - n –æ–ø–µ—Ä–∞—Ü–∏–π
    // –ï—Å–ª–∏ —ç–ª–µ–º–µ–Ω—Ç –≤ –Ω–∞—á–∞–ª–µ - 1 –æ–ø–µ—Ä–∞—Ü–∏—è
    // –í —Å—Ä–µ–¥–Ω–µ–º - n/2 –æ–ø–µ—Ä–∞—Ü–∏–π, –Ω–æ Big O —É—á–∏—Ç—ã–≤–∞–µ—Ç —Ö—É–¥—à–∏–π —Å–ª—É—á–∞–π = O(n)

    for i := 0; i < len(array); i++ {  // –ú–∞–∫—Å–∏–º—É–º n –∏—Ç–µ—Ä–∞—Ü–∏–π
        if array[i] == target {        // –û–¥–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è - O(1)
            return i  // –ù–∞–π–¥–µ–Ω —ç–ª–µ–º–µ–Ω—Ç
        }
    }

    return -1  // –≠–ª–µ–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤—Å–µ—Ö n —ç–ª–µ–º–µ–Ω—Ç–æ–≤
}

// ==================== –ü–†–ò–ú–ï–†: –°–£–ú–ú–ò–†–û–í–ê–ù–ò–ï –ú–ê–°–°–ò–í–ê ====================
func sumArray(numbers []int) int {
    sum := 0

    // –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –Ω—É–∂–Ω–æ –ø—Ä–æ–π—Ç–∏ –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç –æ–¥–∏–Ω —Ä–∞–∑
    // –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –≤—ã—á–∏—Å–ª–∏—Ç—å —Å—É–º–º—É –±—ã—Å—Ç—Ä–µ–µ —á–µ–º –∑–∞ O(n)
    for _, num := range numbers {  // –†–æ–≤–Ω–æ n –∏—Ç–µ—Ä–∞—Ü–∏–π
        sum += num  // –ö–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è - O(1)
    }

    return sum  // –û–±—â–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: n * O(1) = O(n)
}
```

```python
# ==================== –ü–†–ò–ú–ï–†: –§–ò–õ–¨–¢–†–ê–¶–ò–Ø –°–ü–ò–°–ö–ê ====================

def filter_even_numbers(numbers):
    """
    –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —á–µ—Ç–Ω—ã—Ö —á–∏—Å–µ–ª - O(n) –≤—Ä–µ–º—è, O(n) –ø–∞–º—è—Ç—å
    """
    result = []  # –ù–æ–≤—ã–π —Å–ø–∏—Å–æ–∫ –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞

    # –ü—Ä–æ—Ö–æ–¥–∏–º –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤—Ö–æ–¥–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞
    for num in numbers:  # O(n) –∏—Ç–µ—Ä–∞—Ü–∏–π
        if num % 2 == 0:  # O(1) - –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ç–Ω–æ—Å—Ç–∏
            result.append(num)  # O(1) - –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω–µ—Ü —Å–ø–∏—Å–∫–∞

    return result  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–æ–≤—ã–π —Å–ø–∏—Å–æ–∫

# ==================== –†–ï–ê–õ–¨–ù–´–ï –ü–†–ò–ú–ï–ù–ï–ù–ò–Ø O(n) ====================
# - –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Å–µ—Ö –ø–æ–ª–µ–π —Ñ–æ—Ä–º—ã
# - –ü–æ–¥—Å—á–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º
# - –û–±—Ä–∞–±–æ—Ç–∫–∞ –ª–æ–≥–æ–≤ —Å–µ—Ä–≤–µ—Ä–∞
# - –ü–∞—Ä—Å–∏–Ω–≥ JSON/XML –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
```

### O(n log n) - –õ–∏–Ω–µ–π–Ω–æ-–ª–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–æ–µ –≤—Ä–µ–º—è

**–û–ø–∏—Å–∞–Ω–∏–µ:** –û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å –¥–ª—è –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ–º

```go
// ==================== –ü–†–ò–ú–ï–†: MERGE SORT (–°–û–†–¢–ò–†–û–í–ö–ê –°–õ–ò–Ø–ù–ò–ï–ú) ====================
// –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n log n) - –≤–æ –≤—Å–µ—Ö —Å–ª—É—á–∞—è—Ö (best, average, worst)
// –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n) - –¥–ª—è –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–æ–≥–æ –º–∞—Å—Å–∏–≤–∞

func mergeSort(arr []int) []int {
    // ==================== –ë–ê–ó–û–í–´–ô –°–õ–£–ß–ê–ô –†–ï–ö–£–†–°–ò–ò ====================
    // –ú–∞—Å—Å–∏–≤ –∏–∑ 0 –∏–ª–∏ 1 —ç–ª–µ–º–µ–Ω—Ç–∞ —É–∂–µ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω
    if len(arr) <= 1 {
        return arr  // O(1) - –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–µ –≤—Ä–µ–º—è
    }

    // ==================== –†–ê–ó–î–ï–õ–ï–ù–ò–ï –ú–ê–°–°–ò–í–ê ====================
    // –î–µ–ª–∏–º –º–∞—Å—Å–∏–≤ –ø–æ–ø–æ–ª–∞–º - —ç—Ç–æ –¥–∞–µ—Ç –Ω–∞–º log n —É—Ä–æ–≤–Ω–µ–π —Ä–µ–∫—É—Ä—Å–∏–∏
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ª–µ–≤–æ–π —á–∞—Å—Ç–∏
    right := mergeSort(arr[mid:])   // –†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø—Ä–∞–≤–æ–π —á–∞—Å—Ç–∏

    // ==================== –°–õ–ò–Ø–ù–ò–ï –û–¢–°–û–†–¢–ò–†–û–í–ê–ù–ù–´–• –ß–ê–°–¢–ï–ô ====================
    // –ù–∞ –∫–∞–∂–¥–æ–º —É—Ä–æ–≤–Ω–µ –º—ã –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ n —ç–ª–µ–º–µ–Ω—Ç–æ–≤
    return merge(left, right)  // O(n) - —Å–ª–∏—è–Ω–∏–µ –¥–≤—É—Ö –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤
}

func merge(left, right []int) []int {
    // ==================== –°–õ–ò–Ø–ù–ò–ï –î–í–£–• –û–¢–°–û–†–¢–ò–†–û–í–ê–ù–ù–´–• –ú–ê–°–°–ò–í–û–í ====================
    // –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n) –≥–¥–µ n = len(left) + len(right)

    result := make([]int, 0, len(left)+len(right))  // –†–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â–∏–π –º–∞—Å—Å–∏–≤
    i, j := 0, 0  // –£–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ —Ç–µ–∫—É—â–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ left –∏ right

    // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –∏ –¥–æ–±–∞–≤–ª—è–µ–º –º–µ–Ω—å—à–∏–π –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    for i < len(left) && j < len(right) {
        if left[i] <= right[j] {
            result = append(result, left[i])  // –î–æ–±–∞–≤–ª—è–µ–º –∏–∑ –ª–µ–≤–æ–≥–æ –º–∞—Å—Å–∏–≤–∞
            i++
        } else {
            result = append(result, right[j])  // –î–æ–±–∞–≤–ª—è–µ–º –∏–∑ –ø—Ä–∞–≤–æ–≥–æ –º–∞—Å—Å–∏–≤–∞
            j++
        }
    }

    // –î–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —ç–ª–µ–º–µ–Ω—Ç—ã (–æ–¥–∏–Ω –∏–∑ –º–∞—Å—Å–∏–≤–æ–≤ —É–∂–µ –∑–∞–∫–æ–Ω—á–∏–ª—Å—è)
    result = append(result, left[i:]...)   // –û—Å—Ç–∞–≤—à–∏–µ—Å—è –∏–∑ –ª–µ–≤–æ–≥–æ
    result = append(result, right[j:]...)  // –û—Å—Ç–∞–≤—à–∏–µ—Å—è –∏–∑ –ø—Ä–∞–≤–æ–≥–æ

    return result
}

// ==================== –ê–ù–ê–õ–ò–ó –°–õ–û–ñ–ù–û–°–¢–ò MERGE SORT ====================
// 1. –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—Ä–æ–≤–Ω–µ–π —Ä–µ–∫—É—Ä—Å–∏–∏: log n (–∫–∞–∂–¥—ã–π —Ä–∞–∑ –¥–µ–ª–∏–º –ø–æ–ø–æ–ª–∞–º)
// 2. –†–∞–±–æ—Ç–∞ –Ω–∞ –∫–∞–∂–¥–æ–º —É—Ä–æ–≤–Ω–µ: O(n) (—Å–ª–∏—è–Ω–∏–µ –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤)
// 3. –û–±—â–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: log n * n = O(n log n)
//
// –ü—Ä–∏–º–µ—Ä –¥–ª—è –º–∞—Å—Å–∏–≤–∞ –≤ 8 —ç–ª–µ–º–µ–Ω—Ç–æ–≤:
// –£—Ä–æ–≤–µ–Ω—å 0: [8,3,2,4,7,6,1,5] - 1 –º–∞—Å—Å–∏–≤ –ø–æ 8 —ç–ª–µ–º–µ–Ω—Ç–æ–≤
// –£—Ä–æ–≤–µ–Ω—å 1: [8,3,2,4] [7,6,1,5] - 2 –º–∞—Å—Å–∏–≤–∞ –ø–æ 4 —ç–ª–µ–º–µ–Ω—Ç–∞
// –£—Ä–æ–≤–µ–Ω—å 2: [8,3][2,4] [7,6][1,5] - 4 –º–∞—Å—Å–∏–≤–∞ –ø–æ 2 —ç–ª–µ–º–µ–Ω—Ç–∞
// –£—Ä–æ–≤–µ–Ω—å 3: [8][3][2][4] [7][6][1][5] - 8 –º–∞—Å—Å–∏–≤–æ–≤ –ø–æ 1 —ç–ª–µ–º–µ–Ω—Ç—É
// –í—Å–µ–≥–æ —É—Ä–æ–≤–Ω–µ–π: log‚ÇÇ(8) = 3
```

### O(n¬≤) - –ö–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–æ–µ –≤—Ä–µ–º—è

**–û–ø–∏—Å–∞–Ω–∏–µ:** –í—Ä–µ–º—è —Ä–∞—Å—Ç–µ—Ç –∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–æ. –ß–∞—Å—Ç–æ —Å–≤—è–∑–∞–Ω–æ —Å –≤–ª–æ–∂–µ–Ω–Ω—ã–º–∏ —Ü–∏–∫–ª–∞–º–∏.

```go
// ==================== –ü–†–ò–ú–ï–†: BUBBLE SORT (–ü–£–ó–´–†–¨–ö–û–í–ê–Ø –°–û–†–¢–ò–†–û–í–ö–ê) ====================
// –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n¬≤) - –∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–æ–µ –≤—Ä–µ–º—è
// –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1) - –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–∞—è –ø–∞–º—è—Ç—å (—Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –Ω–∞ –º–µ—Å—Ç–µ)

func bubbleSort(arr []int) {
    n := len(arr)

    // ==================== –í–ù–ï–®–ù–ò–ô –¶–ò–ö–õ ====================
    // –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è n —Ä–∞–∑ (–¥–ª—è –∫–∞–∂–¥–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞)
    for i := 0; i < n-1; i++ {

        // ==================== –í–ù–£–¢–†–ï–ù–ù–ò–ô –¶–ò–ö–õ ====================
        // –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è (n-1), (n-2), ..., 1 —Ä–∞–∑
        // –í —Å—É–º–º–µ: (n-1) + (n-2) + ... + 1 = n(n-1)/2 ‚âà n¬≤/2
        for j := 0; j < n-1-i; j++ {

            // ==================== –°–†–ê–í–ù–ï–ù–ò–ï –ò –û–ë–ú–ï–ù ====================
            // –ö–∞–∂–¥–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –∑–∞ O(1)
            if arr[j] > arr[j+1] {
                // –û–±–º–µ–Ω –º–µ—Å—Ç–∞–º–∏ (swap) - O(1)
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }

    // ==================== –ê–ù–ê–õ–ò–ó –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò ====================
    // –î–ª—è –º–∞—Å—Å–∏–≤–∞ –≤ 1000 —ç–ª–µ–º–µ–Ω—Ç–æ–≤:
    // - Bubble Sort: ~1,000,000 –æ–ø–µ—Ä–∞—Ü–∏–π
    // - Merge Sort: ~10,000 –æ–ø–µ—Ä–∞—Ü–∏–π
    // - Binary Search: ~10 –æ–ø–µ—Ä–∞—Ü–∏–π
}

// ==================== –ü–†–ò–ú–ï–†: –ü–û–ò–°–ö –î–£–ë–õ–ò–ö–ê–¢–û–í (NAIVE APPROACH) ====================
func findDuplicatesNaive(arr []int) [][]int {
    var duplicates [][]int

    // ==================== –í–õ–û–ñ–ï–ù–ù–´–ï –¶–ò–ö–õ–´ = O(n¬≤) ====================
    for i := 0; i < len(arr); i++ {      // –í–Ω–µ—à–Ω–∏–π —Ü–∏–∫–ª: n –∏—Ç–µ—Ä–∞—Ü–∏–π
        for j := i + 1; j < len(arr); j++ {  // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ü–∏–∫–ª: (n-1) + (n-2) + ... + 1
            if arr[i] == arr[j] {
                duplicates = append(duplicates, []int{i, j})
            }
        }
    }

    return duplicates

    // ==================== –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –í–ï–†–°–ò–Ø O(n) ====================
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ö—ç—à–º–∞–ø—É –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —É–≤–∏–¥–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
}

func findDuplicatesOptimized(arr []int) map[int][]int {
    seen := make(map[int][]int)

    // –û–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥ –ø–æ –º–∞—Å—Å–∏–≤—É - O(n)
    for i, val := range arr {
        seen[val] = append(seen[val], i)  // O(1) –≤ —Å—Ä–µ–¥–Ω–µ–º
    }

    // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –¥—É–±–ª–∏–∫–∞—Ç—ã
    duplicates := make(map[int][]int)
    for val, indices := range seen {
        if len(indices) > 1 {
            duplicates[val] = indices
        }
    }

    return duplicates  // O(n) –æ–±—â–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å –≤–º–µ—Å—Ç–æ O(n¬≤)
}
```

### O(2‚Åø) - –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è

**–û–ø–∏—Å–∞–Ω–∏–µ:** –í—Ä–µ–º—è —É–¥–≤–∞–∏–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∫–∞–∂–¥–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞. –ö—Ä–∞–π–Ω–µ –º–µ–¥–ª–µ–Ω–Ω–æ.

```go
// ==================== –ü–†–ò–ú–ï–†: –ß–ò–°–õ–ê –§–ò–ë–û–ù–ê–ß–ß–ò (NAIVE RECURSION) ====================
// –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(2‚Åø) - —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è
// –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n) - –≥–ª—É–±–∏–Ω–∞ —Ä–µ–∫—É—Ä—Å–∏–∏

func fibonacciNaive(n int) int {
    // ==================== –ë–ê–ó–û–í–´–ï –°–õ–£–ß–ê–ò ====================
    if n <= 1 {
        return n  // F(0) = 0, F(1) = 1
    }

    // ==================== –†–ï–ö–£–†–°–ò–í–ù–´–ï –í–´–ó–û–í–´ ====================
    // –ö–∞–∂–¥—ã–π –≤—ã–∑–æ–≤ –ø–æ—Ä–æ–∂–¥–∞–µ—Ç 2 –Ω–æ–≤—ã—Ö –≤—ã–∑–æ–≤–∞
    // F(n) = F(n-1) + F(n-2)
    return fibonacciNaive(n-1) + fibonacciNaive(n-2)

    // ==================== –ü–†–û–ë–õ–ï–ú–ê: –ü–û–í–¢–û–†–ù–´–ï –í–´–ß–ò–°–õ–ï–ù–ò–Ø ====================
    // F(5) = F(4) + F(3)
    // F(4) = F(3) + F(2)  <- F(3) –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –¥–≤–∞–∂–¥—ã!
    // F(3) = F(2) + F(1)  <- F(2) –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è —Ç—Ä–∏–∂–¥—ã!
    //
    // –î–µ—Ä–µ–≤–æ –≤—ã–∑–æ–≤–æ–≤ —Ä–∞—Å—Ç–µ—Ç —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ:
    // F(40) ‚Üí ~1.6 –º–∏–ª–ª–∏–∞—Ä–¥–∞ –≤—ã–∑–æ–≤–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏!
}

// ==================== –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –í–ï–†–°–ò–Ø –° –ú–ï–ú–û–ò–ó–ê–¶–ò–ï–ô ====================
// –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n) - –ª–∏–Ω–µ–π–Ω–æ–µ –≤—Ä–µ–º—è
// –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n) - –¥–ª—è –∫—ç—à–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤

func fibonacciMemo(n int, memo map[int]int) int {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à –ø–µ—Ä–µ–¥ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ–º
    if val, exists := memo[n]; exists {
        return val  // –£–∂–µ –≤—ã—á–∏—Å–ª–µ–Ω–æ - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–∑ –∫—ç—à–∞ O(1)
    }

    // –ë–∞–∑–æ–≤—ã–µ —Å–ª—É—á–∞–∏
    if n <= 1 {
        memo[n] = n
        return n
    }

    // –í—ã—á–∏—Å–ª—è–µ–º –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—ç—à
    result := fibonacciMemo(n-1, memo) + fibonacciMemo(n-2, memo)
    memo[n] = result  // –ö—ç—à–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç

    return result

    // ==================== –£–õ–£–ß–®–ï–ù–ò–ï –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò ====================
    // F(40) naive: ~1.6 –º–∏–ª–ª–∏–∞—Ä–¥–∞ –æ–ø–µ—Ä–∞—Ü–∏–π, –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è ~—Å–µ–∫—É–Ω–¥—ã
    // F(40) memo:  ~40 –æ–ø–µ—Ä–∞—Ü–∏–π, –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è ~–º–∏–∫—Ä–æ—Å–µ–∫—É–Ω–¥—ã
}
```

---

## –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å

**Space Complexity** –æ–ø–∏—Å—ã–≤–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–π –∞–ª–≥–æ—Ä–∏—Ç–º—É.

### –¢–∏–ø—ã –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–æ–π —Å–ª–æ–∂–Ω–æ—Å—Ç–∏

```go
// ==================== O(1) - –ö–û–ù–°–¢–ê–ù–¢–ù–ê–Ø –ü–ê–ú–Ø–¢–¨ ====================
func constantSpace(arr []int) int {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
    max := arr[0]     // O(1) –ø–∞–º—è—Ç—å
    sum := 0          // O(1) –ø–∞–º—è—Ç—å

    for _, val := range arr {
        if val > max {
            max = val  // –ü–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ–º, –Ω–µ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –ø–∞–º—è—Ç—å
        }
        sum += val
    }

    return sum
    // –û–±—â–∞—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø–∞–º—è—Ç—å: O(1)
}

// ==================== O(n) - –õ–ò–ù–ï–ô–ù–ê–Ø –ü–ê–ú–Ø–¢–¨ ====================
func linearSpace(arr []int) []int {
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –º–∞—Å—Å–∏–≤ —Ç–æ–≥–æ –∂–µ —Ä–∞–∑–º–µ—Ä–∞
    doubled := make([]int, len(arr))  // O(n) –ø–∞–º—è—Ç—å

    for i, val := range arr {
        doubled[i] = val * 2
    }

    return doubled
    // –û–±—â–∞—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø–∞–º—è—Ç—å: O(n)
}

// ==================== O(log n) - –õ–û–ì–ê–†–ò–§–ú–ò–ß–ï–°–ö–ê–Ø –ü–ê–ú–Ø–¢–¨ ====================
func binarySearchRecursive(arr []int, target, left, right int) int {
    if left > right {
        return -1
    }

    mid := left + (right-left)/2

    if arr[mid] == target {
        return mid
    } else if arr[mid] < target {
        // –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –≤—ã–∑–æ–≤ —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π frame –≤ —Å—Ç–µ–∫–µ
        return binarySearchRecursive(arr, target, mid+1, right)
    } else {
        return binarySearchRecursive(arr, target, left, mid-1)
    }

    // –ì–ª—É–±–∏–Ω–∞ —Ä–µ–∫—É—Ä—Å–∏–∏ = O(log n)
    // –ö–∞–∂–¥—ã–π –≤—ã–∑–æ–≤ –¥–æ–±–∞–≤–ª—è–µ—Ç frame –≤ —Å—Ç–µ–∫ = O(log n) –ø–∞–º—è—Ç—å
}
```

---

## üîç –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ—Ä—ã –∞–Ω–∞–ª–∏–∑–∞

### –ê–Ω–∞–ª–∏–∑ —Å–ª–æ–∂–Ω–æ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞

```python
def complex_algorithm(matrix):
    """
    –ê–Ω–∞–ª–∏–∑ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ —Å–ª–æ–∂–Ω–æ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞
    """
    n = len(matrix)        # –†–∞–∑–º–µ—Ä –º–∞—Ç—Ä–∏—Ü—ã n√ón
    result = []           # O(1) - —Å–æ–∑–¥–∞–Ω–∏–µ —Å–ø–∏—Å–∫–∞

    # ==================== –ë–õ–û–ö 1: O(n¬≤) ====================
    # –ü—Ä–æ—Ö–æ–¥ –ø–æ –≤—Å–µ–π –º–∞—Ç—Ä–∏—Ü–µ
    for i in range(n):         # O(n) –∏—Ç–µ—Ä–∞—Ü–∏–π
        for j in range(n):     # O(n) –∏—Ç–µ—Ä–∞—Ü–∏–π –¥–ª—è –∫–∞–∂–¥–æ–≥–æ i
            if matrix[i][j] > 0:
                result.append((i, j))  # O(1) - –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω–µ—Ü —Å–ø–∏—Å–∫–∞
    # –°–ª–æ–∂–Ω–æ—Å—Ç—å –±–ª–æ–∫–∞ 1: O(n¬≤)

    # ==================== –ë–õ–û–ö 2: O(n log n) ====================
    # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
    result.sort()              # Python –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Timsort - O(n log n)
    # –≥–¥–µ n –∑–¥–µ—Å—å = –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ ‚â§ n¬≤
    # –í —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ: O(n¬≤ log n¬≤) = O(2n¬≤ log n) = O(n¬≤ log n)

    # ==================== –ë–õ–û–ö 3: O(n) ====================
    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
    processed = []
    for coord in result:       # O(len(result)) ‚â§ O(n¬≤)
        processed.append(coord[0] + coord[1])  # O(1)

    # ==================== –û–ë–©–ê–Ø –°–õ–û–ñ–ù–û–°–¢–¨ ====================
    # –í—Ä–µ–º–µ–Ω–Ω–∞—è: O(n¬≤) + O(n¬≤ log n) + O(n¬≤) = O(n¬≤ log n)
    # –î–æ–º–∏–Ω–∏—Ä—É–µ—Ç —Å–∞–º—ã–π –º–µ–¥–ª–µ–Ω–Ω—ã–π –±–ª–æ–∫: O(n¬≤ log n)

    # –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è: O(n¬≤) –¥–ª—è result + O(n¬≤) –¥–ª—è processed = O(n¬≤)

    return processed
```

### –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤

```go
// ==================== –ó–ê–î–ê–ß–ê: –ù–ê–ô–¢–ò –î–í–ê –ß–ò–°–õ–ê, –°–£–ú–ú–ê –ö–û–¢–û–†–´–• –†–ê–í–ù–ê TARGET ====================

// ‚ùå –ù–ï–û–ü–¢–ò–ú–ê–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï: O(n¬≤) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å
func twoSumBruteForce(nums []int, target int) []int {
    n := len(nums)

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø–∞—Ä—ã
    for i := 0; i < n-1; i++ {         // O(n) –∏—Ç–µ—Ä–∞—Ü–∏–π
        for j := i + 1; j < n; j++ {   // O(n) –∏—Ç–µ—Ä–∞—Ü–∏–π –≤ —Å—Ä–µ–¥–Ω–µ–º
            if nums[i]+nums[j] == target {
                return []int{i, j}
            }
        }
    }

    return nil
    // –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n¬≤) - –∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–æ–µ –≤—Ä–µ–º—è
    // –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(1) - –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–∞—è –ø–∞–º—è—Ç—å
}

// ‚úÖ –û–ü–¢–ò–ú–ê–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï: O(n) –≤—Ä–µ–º—è, O(n) –ø–∞–º—è—Ç—å
func twoSumOptimal(nums []int, target int) []int {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ö—ç—à–º–∞–ø—É –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —É–≤–∏–¥–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª
    seen := make(map[int]int)  // O(n) –ø–∞–º—è—Ç—å –≤ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ

    for i, num := range nums {           // O(n) –∏—Ç–µ—Ä–∞—Ü–∏–π
        complement := target - num       // O(1) - –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è

        if index, found := seen[complement]; found {  // O(1) - –ø–æ–∏—Å–∫ –≤ —Ö—ç—à–º–∞–ø–µ
            return []int{index, i}       // –ù–∞—à–ª–∏ –ø–∞—Ä—É!
        }

        seen[num] = i                    // O(1) - –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ —Ö—ç—à–º–∞–ø—É
    }

    return nil
    // –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n) - –ª–∏–Ω–µ–π–Ω–æ–µ –≤—Ä–µ–º—è
    // –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n) - –¥–ª—è —Ö—ç—à–º–∞–ø—ã
}

// ==================== –°–†–ê–í–ù–ï–ù–ò–ï –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò ====================
// –í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: –º–∞—Å—Å–∏–≤ –∏–∑ 10,000 —ç–ª–µ–º–µ–Ω—Ç–æ–≤
//
// Brute Force:    10,000¬≤ = 100,000,000 –æ–ø–µ—Ä–∞—Ü–∏–π
// Optimal:        10,000 –æ–ø–µ—Ä–∞—Ü–∏–π
//
// –†–∞–∑–Ω–∏—Ü–∞: –≤ 10,000 —Ä–∞–∑ –±—ã—Å—Ç—Ä–µ–µ!
```
---

## üìà –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Ä–æ—Å—Ç–∞

**–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ä–∞–∑–º–µ—Ä–æ–≤ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö:**

| n | O(1) | O(log n) | O(n) | O(n log n) | O(n¬≤) | O(2‚Åø) |
|---|------|----------|------|------------|-------|-------|
| 1 | 1 | 1 | 1 | 1 | 1 | 2 |
| 10 | 1 | 3 | 10 | 33 | 100 | 1,024 |
| 100 | 1 | 7 | 100 | 664 | 10,000 | 2¬≥‚Å∞ |
| 1,000 | 1 | 10 | 1,000 | 9,966 | 1,000,000 | ‚àû |

**–í—ã–≤–æ–¥—ã:**
- **O(1), O(log n)** - –æ—Ç–ª–∏—á–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
- **O(n), O(n log n)** - —Ö–æ—Ä–æ—à–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
- **O(n¬≤)** - –ø—Ä–∏–µ–º–ª–µ–º–æ –¥–ª—è –Ω–µ–±–æ–ª—å—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö
- **O(2‚Åø)** - –∏–∑–±–µ–≥–∞—Ç—å –≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ!

---

## –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏ –≤ –∞–Ω–∞–ª–∏–∑–µ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏

### ‚ùå –û—à–∏–±–∫–∞ 1: –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–æ–º–∏–Ω–∏—Ä—É—é—â–µ–≥–æ —Å–ª–∞–≥–∞–µ–º–æ–≥–æ

```go
// –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û: O(n + n¬≤) = O(n¬≤)
// –ü–†–ê–í–ò–õ–¨–ù–û: O(n¬≤)

func incorrectAnalysis(arr []int) {
    // –ë–ª–æ–∫ 1: O(n)
    for i := range arr {
        fmt.Println(arr[i])
    }

    // –ë–ª–æ–∫ 2: O(n¬≤) - –¥–æ–º–∏–Ω–∏—Ä—É–µ—Ç!
    for i := range arr {
        for j := range arr {
            fmt.Println(arr[i], arr[j])
        }
    }

    // –û–±—â–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: O(n¬≤), –Ω–µ O(n + n¬≤)
}
```

### ‚ùå –û—à–∏–±–∫–∞ 2: –ü—É—Ç–∞–Ω–∏–µ –ª—É—á—à–µ–≥–æ –∏ —Ö—É–¥—à–µ–≥–æ —Å–ª—É—á–∞—è

```go
// –ë—ã—Å—Ç—Ä–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ (QuickSort)
func quickSort(arr []int) {
    // –õ—É—á—à–∏–π —Å–ª—É—á–∞–π: O(n log n) - —Ö–æ—Ä–æ—à–µ–µ —Ä–∞–∑–±–∏–µ–Ω–∏–µ
    // –•—É–¥—à–∏–π —Å–ª—É—á–∞–π: O(n¬≤) - –ø–ª–æ—Ö–æ–µ —Ä–∞–∑–±–∏–µ–Ω–∏–µ (—É–∂–µ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤)
    // –°—Ä–µ–¥–Ω–∏–π —Å–ª—É—á–∞–π: O(n log n)

    // Big O –æ–ø–∏—Å—ã–≤–∞–µ—Ç –•–£–î–®–ò–ô —Å–ª—É—á–∞–π: O(n¬≤)
}
```
---
