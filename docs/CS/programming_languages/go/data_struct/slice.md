# Slice
> aka Слайс, aka Срез

Slice - это динамический массив, способный изменять свою длину и содержимое во время рантайма, в отличие от массива.

## Структура темы
- [Как работает?](##how-work)
- [Обьявление](##declaration)
- [Методы](##methods)
- [Хорошие практики](##best-practices)
- [Ссылки](##links)


## Как работает?{##how-work}

Слайс представляет собой структуру, которая содержит указатель на массив, длину и емкость.
Длина слайса - это количество элементов, которые он содержит.
Емкость слайса - это количество элементов, которые он может содержать без необходимости выделения нового блока памяти. То есть, если слайс превашает capacity(емкость), то при добавлении нового элемента произойдет перераспределение массива в памяти - массив выделится в другом месте.

### Реализация:
```go
type slice struct {
	array unsafe.Pointer //uint32 or uint64
	len int //4 or 8 byte
	cap int //4 or 8 byte
}
```


## Обьявление:{##declaration}
```go
var slice_var[] int // Инициализая слайса с  nil => slice.array = nil

array := [3]int{1, 2, 3} // Массив
slice_from_array := array[:4] // Создание слайса из массива - оно же срез не включая 4 элемент

slice := []int{1, 2, 3, 4, 5} // Создание слайса из литерала

slice_make := make([]int, 0) // Создание слайса с нулевой длиной и нулевой емкостью
slice_make1 := make([]int, 0, 10) // Создание слайса с нулевой длиной и емкостью 10
slice_make2 := make([]int, 5, 10) // Создание слайса с длиной 5 и емкостью 10
}
```

## Методы{##methods}
Список методов:
```go
len(slice) // Возвращает длину слайса
cap(slice) // Возвращает емкость слайса

append(slice, element) // Добавляет элемент в конец слайса
append(slice, {1, 2, 3}...) // Добавляет элементы в конец слайса
append(slice, slice_2...) // Добавляет элементы из slice_2 в конец слайса

copy(dst, src) // Копирует элементы из src в dst

slice_from_slice := slice[a:b] // Создает срез слайса от индекса a до, не учитывая, b
slice_from_array := array[:4] // Создание слайса из массива - оно же срез не включая 4 элемент
```


## Хорошие практики{##best-practices}
- Использование функции make с заранее заданной вместимостью (cap), чтобы выделить достаточный объём памяти и избежать многократного перераспределения при последовательном добавлении элементов.

- При работе с большими слайсами стараться выполнять операции срезания без копирования, используя **реслайсинг**( slice[start:end] ), чтобы экономить память и время.

- Использование функции copy для аккуратного копирования данных, когда это нужно, вместо использования append с опасностью создания новых массивов.

- По возможности, уменьшать объем временных слайсов и не создавать лишних промежуточных структур, избегая выделения памяти в [горячих путях].

- При необходимости освобождения памяти (например, для очень больших слайсов) использовать обнуление ссылок внутри слайса или создавать новый слайс с меньшей длиной/вместимостью, чтобы сборщик мусора работал эффективнее.

- Понимать особенности передаваемых слайсов по ссылке и значение; избегать ненужных копирований слайсов при передаче в функции.



## Ссылки:{##links}
- [Go](../)
- [Массив](./array.md)
