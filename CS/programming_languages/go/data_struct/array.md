# Массив

Это структура данных, которая представляет собой упорядоченный набор элементов **одного** типа
с фиксированной длиной, которая определяется при создании массива и не может быть изменена!

## Структура темы:
- [Как работает?](##how-work)
- [Обьявление](##declaration)
- [Особенности работы](##features)
- [Возможности](##opportunities)
- [Методы](##methods)
- [Ссылки](##links)


## Как работает?{##how-work}

В памяти массив представлен как последовательный блок значений,
а переменная массива содержит всю эту последовательность целиком, а не указатель.

В Go значение типа и длина массива - это тип данных.
> То есть: `[1]int{1} != [2]int{1, 2}`

### Реализация
```go
type array struct {
	head unsafe.Pointer //указатель на первый элемент массива
	len int //длина массива
	cap int //максимальная вместимость массива
}
```
Capacity в массиве не используется, но может пригодится для работы со слайсами.


## Обьявление{##declaration}

```go
var arr_var [3]int

arr := [3]string{"a", "b", "c"}

fmt.Print(arr_var) //[0 0 0]
fmt.Println(arr) // [a b c]
```
## Особенности работы{##features}
```go
arrCopy := arr //Копирование массива

some_variable := arr[i] //Получение элемента массива по индексу
```

### Итерация по массиву
> [цикл for](../loop.md)

Обычный проход:
```go
for i := 0; i < len(arr); i++ {
	fmt.Println(arr[i])
}
```
- Можно напрямую менять элементы массива
- Не создаются копии элементов --> работа с элементами по адресу


Range:
```go
for _, v := range arr { //Каждая итерация возвращает значение элемента массива как новые переменные
	fmt.Println(value)
}
```
- Упрощенный синтаксис
- Каждая итерация возвращает значение элемента массива как новые переменные
- Чтобы изменить элемент, нужно использовать индекс: `arr[i] = ...`
- Если в теле цикла меняется переменная, представляющая элемент, это не влияет на оригинальный массив.



### Создание слайсов

## Возможности{##opportunities}
Если нужно иметь методы, можно объявить новый тип на базе массива, например:
> Но такую практику используют редко, так как обычно работают со срезами.

```go
type MyArray [5]int

func (a MyArray) Sum() int {
    sum := 0
    for _, v := range a {
        sum += v
    }
    return sum
}
```


## Методы{##methods}
```go
len(arr) //Длина массива
cap(arr) //Вместимость массива | Практически не используется
```

## Ссылки{##links}
- [Go](../)
- [Slice](./slice.md)
- [цикл for](../loop.md)
