# Big O

> Основа для понимания эффективности кода и подготовки к техническим интервью

## Big O
- Это нотация, которая описывает верхнюю границу времени
выполнения алгоритма в зависимости от размера входных данных.

**Основные принципы:**
- Описывает **наихудший случай**
- Игнорирует константы и младшие слагаемые
- Фокусируется на **росте** времени/памяти выполнения при увеличении входных данных

---

## Иерархия сложностей

- O(1) : константное время | время выполнения не **зависит** от размера входных данных
- O(log n) :
- O(n) :
- O(n log n) :
- O(n²) :
- O(2ⁿ) :
- O(n!) :

### O(1) - Константное время

**Описание:** Время выполнения не зависит от размера входных данных

#### Go
```go
// ==================== ПРИМЕР: ДОСТУП К ЭЛЕМЕНТУ МАССИВА ====================
// Временная сложность: O(1) - константное время
// Пространственная сложность: O(1) - константная память

func getArrayElement(arr []int, index int) int {
    // Доступ к элементу массива по индексу всегда занимает одинаковое время
    // независимо от размера массива (1 элемент или 1 миллион)
    return arr[index]  // Одна операция - O(1)
}

// ==================== ПРИМЕР: ОПЕРАЦИИ С ХЭШМАПОЙ ====================
func hashMapOperations() {
    // Создание хэшмапы
    cache := make(map[string]int)

    // Вставка - O(1) в среднем случае
    cache["key1"] = 100  // Константное время

    // Поиск - O(1) в среднем случае
    value := cache["key1"]  // Константное время

    // Удаление - O(1) в среднем случае
    delete(cache, "key1")  // Константное время
}

// ==================== РЕАЛЬНОЕ ПРИМЕНЕНИЕ ====================
// - Кэширование результатов
// - Доступ к конфигурации приложения
// - Операции со стеком (push/pop с конца)
```

#### Python
```python
# ==================== ПРИМЕР НА PYTHON ====================
# Операции с множеством (set) - O(1) в среднем

def set_operations():
    """
    Демонстрация O(1) операций с множеством
    """
    # Создание множества - O(1)
    visited = set()

    # Добавление элемента - O(1) в среднем
    visited.add("user123")  # Константное время независимо от размера set

    # Проверка наличия - O(1) в среднем
    is_visited = "user123" in visited  # Константное время

    # Удаление - O(1) в среднем
    visited.remove("user123")  # Константное время

    return is_visited
```

### O(log n) - Логарифмическое время

**Описание:** Время растет логарифмически. Каждый шаг уменьшает проблему вдвое.

#### Go
```go
// ==================== ПРИМЕР: БИНАРНЫЙ ПОИСК ====================
// Временная сложность: O(log n) - логарифмическое время
// Пространственная сложность: O(1) - константная память

func binarySearch(sortedArray []int, target int) int {
    // Поиск в отсортированном массиве
    left := 0                    // Левая граница
    right := len(sortedArray) - 1 // Правая граница

    // Пока есть область для поиска
    for left <= right {
        // Находим средний индекс (избегаем переполнения)
        mid := left + (right-left)/2

        // ==================== АНАЛИЗ СЛОЖНОСТИ ====================
        // Каждая итерация уменьшает область поиска в 2 раза
        // Максимальное количество итераций = log₂(n)
        // Например: массив 1000 элементов → максимум 10 итераций

        if sortedArray[mid] == target {
            return mid  // Найден элемент - возвращаем индекс
        } else if sortedArray[mid] < target {
            left = mid + 1  // Ищем в правой половине
        } else {
            right = mid - 1  // Ищем в левой половине
        }
    }

    return -1  // Элемент не найден
}

// ==================== ПРИМЕР ИСПОЛЬЗОВАНИЯ ====================
func exampleBinarySearch() {
    // Отсортированный массив - обязательное условие для бинарного поиска
    numbers := []int{1, 3, 5, 7, 9, 11, 13, 15, 17, 19}

    // Поиск числа 7
    index := binarySearch(numbers, 7)

    // Для массива в 10 элементов потребуется максимум log₂(10) ≈ 4 операции
    // Для массива в 1,000,000 элементов → максимум 20 операций!
}
```

### O(n) - Линейное время

**Описание:** Время растет пропорционально размеру входных данных

```go
// ==================== ПРИМЕР: ЛИНЕЙНЫЙ ПОИСК ====================
// Временная сложность: O(n) - линейное время
// Пространственная сложность: O(1) - константная память

func linearSearch(array []int, target int) int {
    // ==================== АНАЛИЗ СЛОЖНОСТИ ====================
    // В худшем случае нужно проверить каждый элемент
    // Если элемент находится в конце или отсутствует - n операций
    // Если элемент в начале - 1 операция
    // В среднем - n/2 операций, но Big O учитывает худший случай = O(n)

    for i := 0; i < len(array); i++ {  // Максимум n итераций
        if array[i] == target {        // Одна операция сравнения - O(1)
            return i  // Найден элемент
        }
    }

    return -1  // Элемент не найден после проверки всех n элементов
}

// ==================== ПРИМЕР: СУММИРОВАНИЕ МАССИВА ====================
func sumArray(numbers []int) int {
    sum := 0

    // Обязательно нужно пройти каждый элемент один раз
    // Невозможно вычислить сумму быстрее чем за O(n)
    for _, num := range numbers {  // Ровно n итераций
        sum += num  // Константная операция - O(1)
    }

    return sum  // Общая сложность: n * O(1) = O(n)
}
```

```python
# ==================== ПРИМЕР: ФИЛЬТРАЦИЯ СПИСКА ====================

def filter_even_numbers(numbers):
    """
    Фильтрация четных чисел - O(n) время, O(n) память
    """
    result = []  # Новый список для результата

    # Проходим каждый элемент входного списка
    for num in numbers:  # O(n) итераций
        if num % 2 == 0:  # O(1) - проверка четности
            result.append(num)  # O(1) - добавление в конец списка

    return result  # Возвращаем новый список

# ==================== РЕАЛЬНЫЕ ПРИМЕНЕНИЯ O(n) ====================
# - Валидация всех полей формы
# - Подсчет статистики по пользователям
# - Обработка логов сервера
# - Парсинг JSON/XML документов
```

### O(n log n) - Линейно-логарифмическое время

**Описание:** Оптимальная сложность для алгоритмов сортировки сравнением

```go
// ==================== ПРИМЕР: MERGE SORT (СОРТИРОВКА СЛИЯНИЕМ) ====================
// Временная сложность: O(n log n) - во всех случаях (best, average, worst)
// Пространственная сложность: O(n) - для вспомогательного массива

func mergeSort(arr []int) []int {
    // ==================== БАЗОВЫЙ СЛУЧАЙ РЕКУРСИИ ====================
    // Массив из 0 или 1 элемента уже отсортирован
    if len(arr) <= 1 {
        return arr  // O(1) - константное время
    }

    // ==================== РАЗДЕЛЕНИЕ МАССИВА ====================
    // Делим массив пополам - это дает нам log n уровней рекурсии
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])    // Рекурсивная сортировка левой части
    right := mergeSort(arr[mid:])   // Рекурсивная сортировка правой части

    // ==================== СЛИЯНИЕ ОТСОРТИРОВАННЫХ ЧАСТЕЙ ====================
    // На каждом уровне мы обрабатываем все n элементов
    return merge(left, right)  // O(n) - слияние двух отсортированных массивов
}

func merge(left, right []int) []int {
    // ==================== СЛИЯНИЕ ДВУХ ОТСОРТИРОВАННЫХ МАССИВОВ ====================
    // Временная сложность: O(n) где n = len(left) + len(right)

    result := make([]int, 0, len(left)+len(right))  // Результирующий массив
    i, j := 0, 0  // Указатели на текущие элементы в left и right

    // Сравниваем элементы и добавляем меньший в результат
    for i < len(left) && j < len(right) {
        if left[i] <= right[j] {
            result = append(result, left[i])  // Добавляем из левого массива
            i++
        } else {
            result = append(result, right[j])  // Добавляем из правого массива
            j++
        }
    }

    // Добавляем оставшиеся элементы (один из массивов уже закончился)
    result = append(result, left[i:]...)   // Оставшиеся из левого
    result = append(result, right[j:]...)  // Оставшиеся из правого

    return result
}

// ==================== АНАЛИЗ СЛОЖНОСТИ MERGE SORT ====================
// 1. Количество уровней рекурсии: log n (каждый раз делим пополам)
// 2. Работа на каждом уровне: O(n) (слияние всех элементов)
// 3. Общая сложность: log n * n = O(n log n)
//
// Пример для массива в 8 элементов:
// Уровень 0: [8,3,2,4,7,6,1,5] - 1 массив по 8 элементов
// Уровень 1: [8,3,2,4] [7,6,1,5] - 2 массива по 4 элемента
// Уровень 2: [8,3][2,4] [7,6][1,5] - 4 массива по 2 элемента
// Уровень 3: [8][3][2][4] [7][6][1][5] - 8 массивов по 1 элементу
// Всего уровней: log₂(8) = 3
```

### O(n²) - Квадратичное время

**Описание:** Время растет квадратично. Часто связано с вложенными циклами.

```go
// ==================== ПРИМЕР: BUBBLE SORT (ПУЗЫРЬКОВАЯ СОРТИРОВКА) ====================
// Временная сложность: O(n²) - квадратичное время
// Пространственная сложность: O(1) - константная память (сортировка на месте)

func bubbleSort(arr []int) {
    n := len(arr)

    // ==================== ВНЕШНИЙ ЦИКЛ ====================
    // Выполняется n раз (для каждого элемента)
    for i := 0; i < n-1; i++ {

        // ==================== ВНУТРЕННИЙ ЦИКЛ ====================
        // Выполняется (n-1), (n-2), ..., 1 раз
        // В сумме: (n-1) + (n-2) + ... + 1 = n(n-1)/2 ≈ n²/2
        for j := 0; j < n-1-i; j++ {

            // ==================== СРАВНЕНИЕ И ОБМЕН ====================
            // Каждая операция выполняется за O(1)
            if arr[j] > arr[j+1] {
                // Обмен местами (swap) - O(1)
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }

    // ==================== АНАЛИЗ ПРОИЗВОДИТЕЛЬНОСТИ ====================
    // Для массива в 1000 элементов:
    // - Bubble Sort: ~1,000,000 операций
    // - Merge Sort: ~10,000 операций
    // - Binary Search: ~10 операций
}

// ==================== ПРИМЕР: ПОИСК ДУБЛИКАТОВ (NAIVE APPROACH) ====================
func findDuplicatesNaive(arr []int) [][]int {
    var duplicates [][]int

    // ==================== ВЛОЖЕННЫЕ ЦИКЛЫ = O(n²) ====================
    for i := 0; i < len(arr); i++ {      // Внешний цикл: n итераций
        for j := i + 1; j < len(arr); j++ {  // Внутренний цикл: (n-1) + (n-2) + ... + 1
            if arr[i] == arr[j] {
                duplicates = append(duplicates, []int{i, j})
            }
        }
    }

    return duplicates

    // ==================== ОПТИМИЗИРОВАННАЯ ВЕРСИЯ O(n) ====================
    // Используем хэшмапу для отслеживания увиденных элементов
}

func findDuplicatesOptimized(arr []int) map[int][]int {
    seen := make(map[int][]int)

    // Один проход по массиву - O(n)
    for i, val := range arr {
        seen[val] = append(seen[val], i)  // O(1) в среднем
    }

    // Фильтруем только дубликаты
    duplicates := make(map[int][]int)
    for val, indices := range seen {
        if len(indices) > 1 {
            duplicates[val] = indices
        }
    }

    return duplicates  // O(n) общая сложность вместо O(n²)
}
```

### O(2ⁿ) - Экспоненциальное время

**Описание:** Время удваивается при добавлении каждого элемента. Крайне медленно.

```go
// ==================== ПРИМЕР: ЧИСЛА ФИБОНАЧЧИ (NAIVE RECURSION) ====================
// Временная сложность: O(2ⁿ) - экспоненциальное время
// Пространственная сложность: O(n) - глубина рекурсии

func fibonacciNaive(n int) int {
    // ==================== БАЗОВЫЕ СЛУЧАИ ====================
    if n <= 1 {
        return n  // F(0) = 0, F(1) = 1
    }

    // ==================== РЕКУРСИВНЫЕ ВЫЗОВЫ ====================
    // Каждый вызов порождает 2 новых вызова
    // F(n) = F(n-1) + F(n-2)
    return fibonacciNaive(n-1) + fibonacciNaive(n-2)

    // ==================== ПРОБЛЕМА: ПОВТОРНЫЕ ВЫЧИСЛЕНИЯ ====================
    // F(5) = F(4) + F(3)
    // F(4) = F(3) + F(2)  <- F(3) вычисляется дважды!
    // F(3) = F(2) + F(1)  <- F(2) вычисляется трижды!
    //
    // Дерево вызовов растет экспоненциально:
    // F(40) → ~1.6 миллиарда вызовов функции!
}

// ==================== ОПТИМИЗИРОВАННАЯ ВЕРСИЯ С МЕМОИЗАЦИЕЙ ====================
// Временная сложность: O(n) - линейное время
// Пространственная сложность: O(n) - для кэша результатов

func fibonacciMemo(n int, memo map[int]int) int {
    // Проверяем кэш перед вычислением
    if val, exists := memo[n]; exists {
        return val  // Уже вычислено - возвращаем из кэша O(1)
    }

    // Базовые случаи
    if n <= 1 {
        memo[n] = n
        return n
    }

    // Вычисляем и сохраняем в кэш
    result := fibonacciMemo(n-1, memo) + fibonacciMemo(n-2, memo)
    memo[n] = result  // Кэшируем результат

    return result

    // ==================== УЛУЧШЕНИЕ ПРОИЗВОДИТЕЛЬНОСТИ ====================
    // F(40) naive: ~1.6 миллиарда операций, время выполнения ~секунды
    // F(40) memo:  ~40 операций, время выполнения ~микросекунды
}
```

---

## Пространственная сложность

**Space Complexity** описывает количество дополнительной памяти, необходимой алгоритму.

### Типы пространственной сложности

```go
// ==================== O(1) - КОНСТАНТНАЯ ПАМЯТЬ ====================
func constantSpace(arr []int) int {
    // Используем фиксированное количество переменных
    max := arr[0]     // O(1) память
    sum := 0          // O(1) память

    for _, val := range arr {
        if val > max {
            max = val  // Перезаписываем, не создаем новую память
        }
        sum += val
    }

    return sum
    // Общая дополнительная память: O(1)
}

// ==================== O(n) - ЛИНЕЙНАЯ ПАМЯТЬ ====================
func linearSpace(arr []int) []int {
    // Создаем новый массив того же размера
    doubled := make([]int, len(arr))  // O(n) память

    for i, val := range arr {
        doubled[i] = val * 2
    }

    return doubled
    // Общая дополнительная память: O(n)
}

// ==================== O(log n) - ЛОГАРИФМИЧЕСКАЯ ПАМЯТЬ ====================
func binarySearchRecursive(arr []int, target, left, right int) int {
    if left > right {
        return -1
    }

    mid := left + (right-left)/2

    if arr[mid] == target {
        return mid
    } else if arr[mid] < target {
        // Рекурсивный вызов создает новый frame в стеке
        return binarySearchRecursive(arr, target, mid+1, right)
    } else {
        return binarySearchRecursive(arr, target, left, mid-1)
    }

    // Глубина рекурсии = O(log n)
    // Каждый вызов добавляет frame в стек = O(log n) память
}
```

---

## 🔍 Практические примеры анализа

### Анализ сложного алгоритма

```python
def complex_algorithm(matrix):
    """
    Анализ сложности сложного алгоритма
    """
    n = len(matrix)        # Размер матрицы n×n
    result = []           # O(1) - создание списка

    # ==================== БЛОК 1: O(n²) ====================
    # Проход по всей матрице
    for i in range(n):         # O(n) итераций
        for j in range(n):     # O(n) итераций для каждого i
            if matrix[i][j] > 0:
                result.append((i, j))  # O(1) - добавление в конец списка
    # Сложность блока 1: O(n²)

    # ==================== БЛОК 2: O(n log n) ====================
    # Сортировка результата
    result.sort()              # Python использует Timsort - O(n log n)
    # где n здесь = количество положительных элементов ≤ n²
    # В худшем случае: O(n² log n²) = O(2n² log n) = O(n² log n)

    # ==================== БЛОК 3: O(n) ====================
    # Обработка отсортированного результата
    processed = []
    for coord in result:       # O(len(result)) ≤ O(n²)
        processed.append(coord[0] + coord[1])  # O(1)

    # ==================== ОБЩАЯ СЛОЖНОСТЬ ====================
    # Временная: O(n²) + O(n² log n) + O(n²) = O(n² log n)
    # Доминирует самый медленный блок: O(n² log n)

    # Пространственная: O(n²) для result + O(n²) для processed = O(n²)

    return processed
```

### Сравнение алгоритмов

```go
// ==================== ЗАДАЧА: НАЙТИ ДВА ЧИСЛА, СУММА КОТОРЫХ РАВНА TARGET ====================

// ❌ НЕОПТИМАЛЬНОЕ РЕШЕНИЕ: O(n²) время, O(1) память
func twoSumBruteForce(nums []int, target int) []int {
    n := len(nums)

    // Проверяем все возможные пары
    for i := 0; i < n-1; i++ {         // O(n) итераций
        for j := i + 1; j < n; j++ {   // O(n) итераций в среднем
            if nums[i]+nums[j] == target {
                return []int{i, j}
            }
        }
    }

    return nil
    // Временная сложность: O(n²) - квадратичное время
    // Пространственная сложность: O(1) - константная память
}

// ✅ ОПТИМАЛЬНОЕ РЕШЕНИЕ: O(n) время, O(n) память
func twoSumOptimal(nums []int, target int) []int {
    // Используем хэшмапу для отслеживания увиденных чисел
    seen := make(map[int]int)  // O(n) память в худшем случае

    for i, num := range nums {           // O(n) итераций
        complement := target - num       // O(1) - вычисление дополнения

        if index, found := seen[complement]; found {  // O(1) - поиск в хэшмапе
            return []int{index, i}       // Нашли пару!
        }

        seen[num] = i                    // O(1) - добавление в хэшмапу
    }

    return nil
    // Временная сложность: O(n) - линейное время
    // Пространственная сложность: O(n) - для хэшмапы
}

// ==================== СРАВНЕНИЕ ПРОИЗВОДИТЕЛЬНОСТИ ====================
// Входные данные: массив из 10,000 элементов
//
// Brute Force:    10,000² = 100,000,000 операций
// Optimal:        10,000 операций
//
// Разница: в 10,000 раз быстрее!
```
---

## 📈 Визуализация роста

**Сравнение времени выполнения для разных размеров входных данных:**

| n | O(1) | O(log n) | O(n) | O(n log n) | O(n²) | O(2ⁿ) |
|---|------|----------|------|------------|-------|-------|
| 1 | 1 | 1 | 1 | 1 | 1 | 2 |
| 10 | 1 | 3 | 10 | 33 | 100 | 1,024 |
| 100 | 1 | 7 | 100 | 664 | 10,000 | 2³⁰ |
| 1,000 | 1 | 10 | 1,000 | 9,966 | 1,000,000 | ∞ |

**Выводы:**
- **O(1), O(log n)** - отличная производительность
- **O(n), O(n log n)** - хорошая производительность
- **O(n²)** - приемлемо для небольших данных
- **O(2ⁿ)** - избегать в продакшене!

---

## Частые ошибки в анализе сложности

### ❌ Ошибка 1: Игнорирование доминирующего слагаемого

```go
// НЕПРАВИЛЬНО: O(n + n²) = O(n²)
// ПРАВИЛЬНО: O(n²)

func incorrectAnalysis(arr []int) {
    // Блок 1: O(n)
    for i := range arr {
        fmt.Println(arr[i])
    }

    // Блок 2: O(n²) - доминирует!
    for i := range arr {
        for j := range arr {
            fmt.Println(arr[i], arr[j])
        }
    }

    // Общая сложность: O(n²), не O(n + n²)
}
```

### ❌ Ошибка 2: Путание лучшего и худшего случая

```go
// Быстрая сортировка (QuickSort)
func quickSort(arr []int) {
    // Лучший случай: O(n log n) - хорошее разбиение
    // Худший случай: O(n²) - плохое разбиение (уже отсортированный массив)
    // Средний случай: O(n log n)

    // Big O описывает ХУДШИЙ случай: O(n²)
}
```
---
